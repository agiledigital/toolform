package au.com.agiledigital.toolform.tasks.generate.docker

import java.io.{BufferedWriter, FileWriter}

import au.com.agiledigital.toolform.app.{ToolFormConfiguration, ToolFormError}
import au.com.agiledigital.toolform.model._
import au.com.agiledigital.toolform.tasks.generate.docker.DockerFormatting._
import au.com.agiledigital.toolform.tasks.generate.docker.SubEdgeDef.subEdgeDefsFromProject
import au.com.agiledigital.toolform.tasks.generate.{WriterContext, YamlWriter}
import au.com.agiledigital.toolform.util.DateUtil
import au.com.agiledigital.toolform.version.BuildInfo
import cats.data.State
import cats.implicits._

/**
  * Takes an abstract project definition and outputs it to a file in the Docker Compose V3 YAML format.
  *
  * Should be run via the GenerateTask class and not directly.
  *
  * @see https://docs.docker.com/compose/compose-file/
  */
object GenerateDockerComposeV3 extends YamlWriter {

  /**
    * A function that just passes state through without modifying it
    */
  val identity: State[WriterContext, Unit] = State[WriterContext, Unit] { context =>
    (context, ())
  }

  /**
    * The main entry point into the Docker Compose file generation.
    *
    * @param toolFormConfiguration  a configuration object that is parsed from command line options.
    * @param project                the abstract project definition parsed by ToolFormApp.
    * @return                       on success it returns a status message to print to the screen, otherwise it will return an
    *                               error object describing what went wrong.
    */
  def runGenerateDockerComposeV3(toolFormConfiguration: ToolFormConfiguration, project: Project): Either[ToolFormError, String] = {
    val outFile        = toolFormConfiguration.generateTaskConfiguration.out
    val sourceFilePath = toolFormConfiguration.in.getAbsolutePath
    val writer         = new BufferedWriter(new FileWriter(outFile, false))
    try {
      val writeFile = for {
        _ <- write(s"# Generated by ${BuildInfo.name} (${BuildInfo.version})")
        _ <- write(s"# Source file: $sourceFilePath")
        _ <- write(s"# Date: ${DateUtil.formattedDateString}")
        _ <- write("version: '3'")
        _ <- write("services:")
        _ <- indented {
          for {
            _ <- writeEdges(project.id, subEdgeDefsFromProject(project).toList)
            _ <- writeComponents(project.id, project.sortedComponents.values.toList)
            _ <- writeResources(project.sortedResources.values.toList)
          } yield ()
        }
      } yield ()

      val context = WriterContext(writer)
      // Final state needs to be read for anything to happen because of lazy evaluation
      val _ = writeFile.run(context).value

      Right("Completed Successfully")
    } finally {
      writer.close()
    }
  }

  def writeEdges(projectId: String, subEdgeDefs: List[SubEdgeDef]): Result[Unit] =
    subEdgeDefs.traverse_((subEdgeDef) => writeSubEdge(projectId, subEdgeDef))

  def writeComponents(projectId: String, components: List[Component]): Result[Unit] =
    components.traverse_((component) => writeComponent(projectId, component))

  def writeResources(resources: List[Resource]): Result[Unit] =
    resources.traverse_(writeResource)

  def writeSubEdge(projectId: String, subEdgeDef: SubEdgeDef): Result[Unit] = {
    val serviceName = subEdgeServiceName(projectId, subEdgeDef)
    val imageName   = subEdgeImageName(projectId, subEdgeDef)
    for {
      _ <- write(s"$serviceName:")
      _ <- indented {
        for {
          _ <- write(s"image: $imageName")
          _ <- write(s"restart: always")
          _ <- write(s"ports:")
          _ <- write(subEdgePortDefinition(subEdgeDef))
        } yield ()
      }
    } yield ()
  }

  def writeComponent(projectId: String, component: Component): Result[Unit] = {
    val serviceName = componentServiceName(component)
    val imageName   = componentImageName(projectId, component)
    for {
      _ <- write(s"$serviceName:")
      _ <- indented {
        for {
          _ <- write(s"image: $imageName")
          _ <- write(s"restart: always")
          _ <- writeComponentLabels(component)
          _ <- writeEnvironmentVariables(component)
          _ <- writePorts(component)
        } yield ()
      }
    } yield ()
  }

  def writeComponentLabels(component: Component): Result[Unit] =
    for {
      _ <- write("labels:")
      _ <- indented {
        for {
          _ <- write(s"source.path: \042${component.path}\042")
          _ <- write("project.artefact: \"true\"")
        } yield ()
      }
    } yield ()

  def writeResource(resource: Resource): Result[Unit] = {
    val serviceName = resourceServiceName(resource)
    for {
      _ <- write(s"$serviceName:")
      _ <- indented {
        for {
          _ <- write(s"image: ${resource.image}")
          _ <- write(s"restart: always")
          _ <- writeEnvironmentVariables(resource)
          _ <- writePorts(resource)
        } yield ()
      }
    } yield ()
  }

  def writeEnvironmentVariables(service: Service): Result[Unit] =
    if (service.environment.nonEmpty) {
      for {
        _ <- write("environment:")
        _ <- service.environment.toList
          .map((entry) => formatEnvironment(entry))
          .traverse_(write)
      } yield ()
    } else {
      identity
    }

  def writePorts(service: Service): Result[Unit] =
    if (service.exposedPorts.nonEmpty) {
      for {
        _ <- write("ports:")
        _ <- service.exposedPorts
          .map((port) => formatPort(port))
          .traverse_(write)
      } yield ()
    } else {
      identity
    }
}
